#pragma kernel TriDiag_PCRy

Texture2D<float4> coefMaty;
Texture2D<float4> current_state;
Texture2D<float4> current_stateUVstar;

int width;
int height;
int p;
int s;

RWTexture2D<float4> newcoefy; //  will store the updated state
RWTexture2D<float4> txNewState; //  will store the updated state

#pragma multi_compile THREADS_8x8 THREADS_16x16 THREADS_32x32

#ifdef THREADS_8x8
#define THREAD_X 8
#define THREAD_Y 8
#elif defined(THREADS_16x16)
#define THREAD_X 16
#define THREAD_Y 16
#elif defined(THREADS_32x32)
#define THREAD_X 32
#define THREAD_Y 32
#endif

[numthreads(THREAD_X, THREAD_Y, 1)]
void TriDiag_PCRy(uint3 id : SV_DispatchThreadID) 
{
    int2 idx = int2(id.xy);
    
    float4 CurrentState = current_state.Load(int3(idx.x, idx.y, 0));
    
    // Initialize state
    newcoefy[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
    txNewState[id.xy] = CurrentState;
    
    // return if in imaginary grid points
    if (idx.x >= width-2 || idx.y >= height-2) return;
    if (idx.x <= 1 || idx.y <= 1) return;

    int2 idx_left = int2(idx.x, (idx.y - s + height) % height);
    int2 idx_right = int2(idx.x, (idx.y + s + height) % height);
	
    float bIn,bInLeft,bInRight;
    float aIn,aInLeft,aInRight;
    float cIn,cInLeft,cInRight;
    float dIn,dInLeft,dInRight;

    if (p == 0) {
        bIn = coefMaty.Load(int3(idx, 0)).g;
        bInLeft = coefMaty.Load(int3(idx_left, 0)).g;
        bInRight = coefMaty.Load(int3(idx_right, 0)).g;

        aIn = coefMaty.Load(int3(idx, 0)).r / bIn;
        aInLeft = coefMaty.Load(int3(idx_left, 0)).r / bInLeft;
        aInRight = coefMaty.Load(int3(idx_right, 0)).r / bInRight;

        cIn = coefMaty.Load(int3(idx, 0)).b / bIn;
        cInLeft = coefMaty.Load(int3(idx_left, 0)).b / bInLeft;
        cInRight = coefMaty.Load(int3(idx_right, 0)).b / bInRight;

        dIn = current_stateUVstar.Load(int3(idx.x, idx.y, 0)).b / bIn;
        dInLeft = current_stateUVstar.Load(int3(idx_left.x, idx_left.y, 0)).b / bInLeft;
        dInRight = current_stateUVstar.Load(int3(idx_right.x, idx_right.y, 0)).b / bInRight;
    }
    else {
        aIn = coefMaty.Load(int3(idx, 0)).r;
        aInLeft = coefMaty.Load(int3(idx_left, 0)).r;
        aInRight = coefMaty.Load(int3(idx_right, 0)).r;

        cIn = coefMaty.Load(int3(idx, 0)).b;
        cInLeft = coefMaty.Load(int3(idx_left, 0)).b;
        cInRight = coefMaty.Load(int3(idx_right, 0)).b;

        dIn = coefMaty.Load(int3(idx, 0)).a;
        dInLeft = coefMaty.Load(int3(idx_left, 0)).a;
        dInRight = coefMaty.Load(int3(idx_right, 0)).a;
    }

    float r = 1.0 / (1.0 - aIn * cInLeft - cIn * aInRight);
    float aOut = -r * aIn * aInLeft;
    float cOut = -r * cIn * cInRight;
    float dOut = r * (dIn - aIn * dInLeft - cIn * dInRight);

    newcoefy[id.xy] = float4(aOut, 1.0, cOut, dOut);
    txNewState[id.xy] = float4(CurrentState.r, CurrentState.g, dOut, CurrentState.a);
}
