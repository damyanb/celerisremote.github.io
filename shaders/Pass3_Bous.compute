#pragma kernel Pass3_Bous

Texture2D<float4> txState;
Texture2D<float4> txBottom;
Texture2D<float4> txH;
Texture2D<float4> txXFlux;
Texture2D<float4> txYFlux;
Texture2D<float4> oldGradients;
Texture2D<float4> oldOldGradients;
Texture2D<float4> predictedGradients;
Texture2D<float4> F_G_star_oldOldGradients;
Texture2D<float4> txstateUVstar;
Texture2D<float4> txShipPressure;

int width;
int height;
float dt;
float dx;
float dy;
float one_over_dx;
float one_over_dy;
float g_over_dx;
float g_over_dy;
int timeScheme;
float epsilon;
int isManning;
float g;
float friction;
int pred_or_corrector;
float Bcoef;
float Bcoef_g;
float one_over_d2x;
float one_over_d3x;
float one_over_d2y;
float one_over_d3y;
float one_over_dxdy;
float seaLevel;

RWTexture2D<float4> txNewState; // will store the updated state
RWTexture2D<float4> dU_by_dt; // will store the updated dU_by_dt
RWTexture2D<float4> F_G_star; // will store the updated F*, G*
RWTexture2D<float4> current_stateUVstar; // will store the updated F*, G*

float FrictionCalc(float hu, float hv, float h)
{
    // Compute divide_by_h
    float h2 = h * h;
    float divide_by_h = 2.0 * h / sqrt(h2 + max(h2, epsilon));

    // Compute f based on the value of isManning
    float f;
    if (isManning == 1)
    {
        f = g * pow(friction, 2.0) * pow(abs(divide_by_h), 1.0 / 3.0);
    }
    else
    {
        f = friction / 2.0;
    }

    // Compute final value of f
    f = f * sqrt(hu * hu + hv * hv) * divide_by_h * divide_by_h;

    // Return f
    return f;
}

#pragma multi_compile THREADS_8x8 THREADS_16x16 THREADS_32x32

#ifdef THREADS_8x8
#define THREAD_X 8
#define THREAD_Y 8
#elif defined(THREADS_16x16)
#define THREAD_X 16
#define THREAD_Y 16
#elif defined(THREADS_32x32)
#define THREAD_X 32
#define THREAD_Y 32
#endif

[numthreads(THREAD_X, THREAD_Y, 1)]
void Pass3_Bous(uint3 id : SV_DispatchThreadID) {

    // Convert the 3D thread ID to a 2D grid coordinate
    int2 idx = int2(id.xy);
    
    // Initialize state, derivatives and fluxes
    float4 zero = float4(0.0, 0.0, 0.0, 0.0);
    txNewState[id.xy] = zero;
    dU_by_dt[id.xy] = zero;
    F_G_star[id.xy] = zero;
    current_stateUVstar[id.xy] = zero;

    // return if in imaginary grid points
    if (idx.x >= width - 2 || idx.y >= height - 2)
        return;
    if (idx.x <= 1 || idx.y <= 1)
        return;

// Handle boundary conditions
    int2 leftIdx = idx + int2(-1, 0);
    int2 rightIdx = idx + int2(1, 0);
    int2 downIdx = idx + int2(0, -1);
    int2 upIdx = idx + int2(0, 1);
    int2 upleftIdx = idx + int2(-1, 1);
    int2 uprightIdx = idx + int2(1, 1);
    int2 downleftIdx = idx + int2(-1, -1);
    int2 downrightIdx = idx + int2(1, -1);

    float B_here = txBottom.Load(int3(idx, 0)).z;
    float near_dry = txBottom.Load(int3(idx, 0)).w;

    float4 in_state_here = txState.Load(int3(idx, 0));
    // Calculate local h,w
    float4 h_vec = txH.Load(int3(idx, 0));
    float h_here = in_state_here.x - B_here;

    // Load values from txXFlux and txYFlux using idx
    float4 xflux_here = txXFlux.Load(int3(idx, 0));
    float4 xflux_west = txXFlux.Load(int3(leftIdx, 0));
    float4 yflux_here = txYFlux.Load(int3(idx, 0));
    float4 yflux_south = txYFlux.Load(int3(downIdx, 0));
    
    float B_south = txBottom.Load(int3(downIdx, 0)).z;
    float B_north = txBottom.Load(int3(upIdx, 0)).z;
    float B_west = txBottom.Load(int3(leftIdx, 0)).z;
    float B_east = txBottom.Load(int3(rightIdx, 0)).z;

    float eta_west = txState.Load(int3(leftIdx, 0)).x;
    float eta_east = txState.Load(int3(rightIdx, 0)).x;
    float eta_south = txState.Load(int3(downIdx, 0)).x;
    float eta_north = txState.Load(int3(upIdx, 0)).x;

    float detadx = 0.5 * (eta_east - eta_west) * one_over_dx;
    float detady = 0.5 * (eta_north - eta_south) * one_over_dy;

    // correction for "small" depth cells, fixes near-shoreline spurious waves
    float minH = min(h_vec.w, min(h_vec.z, min(h_vec.y, h_vec.x)));
    float dB = max(abs(B_south - B_here), max(abs(B_north - B_here), max(abs(B_west - B_here), abs(B_east - B_here))));
    float u_here = in_state_here.y;
    float v_here = in_state_here.z;
    float speed2_here = u_here * u_here + v_here * v_here;
    if (minH * minH < 2.0 * dx * dB && speed2_here < 0.00001 * dB * g)
    { // when the depth is "small" & fluid is not moving, set the free surface slope to zero (stair-step analogy)
        detady = 0;
        detadx = 0;
    }

    float4 oldies = oldGradients.Load(int3(idx, 0));
    float4 oldOldies = oldOldGradients.Load(int3(idx, 0));

    float F_star = 0;
    float G_star = 0;
    float Psi1x = 0;
    float Psi2x = 0;
    float Psi1y = 0;
    float Psi2y = 0;

    float d_here = seaLevel - B_here;
    if (near_dry > 0)
    { // only proceed if not near an initially dry cell
        float d2_here = d_here * d_here;
        float d3_here = d2_here * d_here;
    
        int2 leftleftIdx = idx + int2(-2, 0);
        int2 rightrightIdx = idx + int2(2, 0);
        int2 downdownIdx = idx + int2(0, -2);
        int2 upupIdx = idx + int2(0, 2);

        float3 in_state_right = txState.Load(int3(rightIdx, 0)).xyz;
        float3 in_state_left = txState.Load(int3(leftIdx, 0)).xyz;
        float3 in_state_up = txState.Load(int3(upIdx, 0)).xyz;
        float3 in_state_down = txState.Load(int3(downIdx, 0)).xyz;
        float3 in_state_up_left = txState.Load(int3(upleftIdx, 0)).xyz;
        float3 in_state_up_right = txState.Load(int3(uprightIdx, 0)).xyz;
        float3 in_state_down_left = txState.Load(int3(downleftIdx, 0)).xyz;
        float3 in_state_down_right = txState.Load(int3(downrightIdx, 0)).xyz;

        float3 F_G_star_oldOldies = F_G_star_oldOldGradients.Load(int3(idx, 0)).xyz;

    // Calculate d stencil
        float d_left = seaLevel - B_west;
        float d_right = seaLevel - B_east;
        float d_down = seaLevel - B_south;
        float d_up = seaLevel - B_north;

        float d_left_left = max(0.0, seaLevel - txBottom.Load(int3(leftleftIdx, 0)).z);
        float d_right_right = max(0.0, seaLevel - txBottom.Load(int3(rightrightIdx, 0)).z);
        float d_down_down = max(0.0, seaLevel - txBottom.Load(int3(downdownIdx, 0)).z);
        float d_up_up = max(0.0, seaLevel - txBottom.Load(int3(upupIdx, 0)).z);

    // Calculate eta stencil
        float eta_here = in_state_here.x - seaLevel;
        float eta_left = in_state_left.x - seaLevel;
        float eta_right = in_state_right.x - seaLevel;
        float eta_down = in_state_down.x - seaLevel;
        float eta_up = in_state_up.x - seaLevel;
        float eta_left_left = txState.Load(int3(leftleftIdx, 0)).x - seaLevel;
        float eta_right_right = txState.Load(int3(rightrightIdx, 0)).x - seaLevel;
        float eta_down_down = txState.Load(int3(downdownIdx, 0)).x - seaLevel;
        float eta_up_up = txState.Load(int3(upupIdx, 0)).x - seaLevel;
        float eta_up_left = in_state_up_left.x - seaLevel;
        float eta_up_right = in_state_up_right.x - seaLevel;
        float eta_down_left = in_state_down_left.x - seaLevel;
        float eta_down_right = in_state_down_right.x - seaLevel;

    // replace with 4th order when dispersion is included
    //    float detadx = 1.0f / 12.0f * (eta_left_left - 8.0f * eta_left + 8.0f * eta_right + eta_right_right) * one_over_dx;
    //    float detady = 1.0f / 12.0f * (eta_down_down - 8.0f * eta_down + 8.0f * eta_up + eta_up_up) * one_over_dy;

        float v_up = in_state_up.z;
        float v_down = in_state_down.z;
        float v_right = in_state_right.z;
        float v_left = in_state_left.z;
        float v_up_right = in_state_up_right.z;
        float v_down_right = in_state_down_right.z;
        float v_up_left = in_state_up_left.z;
        float v_down_left = in_state_down_left.z;

        float u_up = in_state_up.y;
        float u_down = in_state_down.y;
        float u_right = in_state_right.y;
        float u_left = in_state_left.y;
        float u_up_right = in_state_up_right.y;
        float u_down_right = in_state_down_right.y;
        float u_up_left = in_state_up_left.y;
        float u_down_left = in_state_down_left.y;

        float dd_by_dx = (-d_right_right + 8.0f * d_right - 8.0f * d_left + d_left_left) * one_over_dx / 12.0f;
        float dd_by_dy = (-d_up_up + 8.0f * d_up - 8.0f * d_down + d_down_down) * one_over_dy / 12.0f;
        float eta_by_dx_dy = 0.25f * one_over_dx * one_over_dy * (eta_up_right - eta_down_right - eta_up_left + eta_down_left);
        float eta_by_dx_dx = one_over_d2x * (eta_right - 2.0f * eta_here + eta_left);
        float eta_by_dy_dy = one_over_d2y * (eta_up - 2.0f * eta_here + eta_down);
        
        F_star = (1.0f / 6.0f) * d_here * (dd_by_dx * (0.5f * one_over_dy) * (v_up - v_down) + dd_by_dy * (0.5f * one_over_dx) * (v_right - v_left)) + (Bcoef + 1.0f / 3.0f) * d2_here * (one_over_dxdy / 4.0f) * (v_up_right - v_down_right - v_up_left + v_down_left);

        G_star = (1.0f / 6.0f) * d_here * (dd_by_dx * (0.5f * one_over_dy) * (u_up - u_down) + dd_by_dy * (0.5f * one_over_dx) * (u_right - u_left)) + (Bcoef + 1.0f / 3.0f) * d2_here * (one_over_dxdy / 4.0f) * (u_up_right - u_down_right - u_up_left + u_down_left);
        
        Psi1x = Bcoef_g * d3_here * ((eta_right_right - 2.0f * eta_right + 2.0 * eta_left - eta_left_left) * (0.5f * one_over_d3x) + (eta_up_right - eta_up_left - 2.0f * eta_right + 2.0f * eta_left + eta_down_right - eta_down_left) * (0.5f * one_over_dx * one_over_d2y));
        Psi2x = Bcoef_g * d2_here * (dd_by_dx * (2.0f * eta_by_dx_dx + eta_by_dy_dy) + dd_by_dy * eta_by_dx_dy) + (F_star - F_G_star_oldOldies.x) / dt / 2.0f;

        Psi1y = Bcoef_g * d3_here * ((eta_up_up - 2.0f * eta_up + 2.0f * eta_down - eta_down_down) * (0.5f * one_over_d3y) + (eta_up_right + eta_up_left - 2.0f * eta_up + 2.0 * eta_down - eta_down_right - eta_down_left) * (0.5f * one_over_dx * one_over_d2x));
        Psi2y = Bcoef_g * d2_here * (dd_by_dy * (2.0f * eta_by_dy_dy + eta_by_dx_dx) + dd_by_dx * eta_by_dx_dy) + (G_star - F_G_star_oldOldies.y) / dt / 2.0f;
    }

    float friction_ = FrictionCalc(in_state_here.x, in_state_here.y, h_here);

    // Calculate pressure stencil
    float P_left = txShipPressure.Load(int3(leftIdx, 0)).x;
    float P_right = txShipPressure.Load(int3(rightIdx, 0)).x;
    float P_down = txShipPressure.Load(int3(downIdx, 0)).x;
    float P_up = txShipPressure.Load(int3(upIdx, 0)).x;

    float press_x = -0.5 * h_here * g_over_dx * (P_right - P_left);
    float press_y = -0.5 * h_here * g_over_dy * (P_up - P_down);

    // Calculate scalar transport additions
    float C_state_here = txState.Load(int3(idx, 0)).w; // c at this cell (cell avgs, evaluated here)
    float C_state_right = txState.Load(int3(rightIdx, 0)).w; // c at right cell (cell avgs, evaluated here)
    float C_state_left = txState.Load(int3(leftIdx, 0)).w; // c at left cell (cell avgs, evaluated here)
    float C_state_up = txState.Load(int3(upIdx, 0)).w; // w, hu and hv at up cell (cell avgs, evaluated here)
    float C_state_down = txState.Load(int3(downIdx, 0)).w; // w, hu and hv at down cell (cell avgs, evaluated here)
    float C_state_up_left = txState.Load(int3(upleftIdx, 0)).w;
    float C_state_up_right = txState.Load(int3(uprightIdx, 0)).w;
    float C_state_down_left = txState.Load(int3(downleftIdx, 0)).w;
    float C_state_down_right = txState.Load(int3(downrightIdx, 0)).w;

    float Dxx = 0.;
    float Dxy = 0.;
    float Dyy = 0.;

    float hc_by_dx_dx = Dxx * one_over_d2x * (C_state_right - 2.0f * in_state_here.a + C_state_left); // SOON
    float hc_by_dy_dy = Dyy * one_over_d2y * (C_state_up - 2.0f * in_state_here.a + C_state_down); // SOON
    float hc_by_dx_dy = 0.25f * Dxy * one_over_dxdy * (C_state_up_right - C_state_up_left - C_state_down_right + C_state_down_left); // SOON

    float c_dissipation = -0.01 * C_state_here;

    float4 source_term = float4(0.0, -g * h_here * detadx - in_state_here.y * friction_ + (Psi1x + Psi2x) + press_x, -g * h_here * detady - in_state_here.z * friction_ + (Psi1y + Psi2y) + press_y, hc_by_dx_dx + hc_by_dy_dy + 2.0f * hc_by_dx_dy + c_dissipation);

    float4 d_by_dt = (xflux_west - xflux_here) * one_over_dx + (yflux_south - yflux_here) * one_over_dy + source_term;

    float4 newState = float4(0., 0., 0., 0.);
    
    float4 in_state_here_UV = txstateUVstar.Load(int3(idx, 0));

    if (timeScheme == 0)
    { // if timeScheme is Euler:
    //    wOut = in_state_here_UV.x + dt * d_by_dt.x;
    //    huOut = in_state_here_UV.y + dt * d_by_dt.y;
    //    hvOut = in_state_here_UV.z + dt * d_by_dt.z;
    //    cOut = in_state_here_UV.w + dt * d_by_dt.w;
        
        newState = in_state_here_UV + dt * d_by_dt;
    }
    else if (pred_or_corrector == 1)
    { // if time scheme is predictor
     //   wOut = in_state_here_UV.x + dt / 12.0 * (23.0 * d_by_dt.x - 16.0 * oldies.x + 5.0 * oldOldies.x);
     //   huOut = in_state_here_UV.y + dt / 12.0 * (23.0 * d_by_dt.y - 16.0 * oldies.y + 5.0 * oldOldies.y);
     //   hvOut = in_state_here_UV.z + dt / 12.0 * (23.0 * d_by_dt.z - 16.0 * oldies.z + 5.0 * oldOldies.z);
     //   cOut = in_state_here_UV.w + dt / 12.0 * (23.0 * d_by_dt.w - 16.0 * oldies.w + 5.0 * oldOldies.w);
        
        newState = in_state_here_UV + dt / 12.0 * (23.0 * d_by_dt - 16.0 * oldies + 5.0 * oldOldies);;
    }
    else if (pred_or_corrector == 2)
    { // if time scheme is corrector
        float4 predicted = predictedGradients.Load(int3(idx, 0));

     //   wOut = in_state_here_UV.x + dt / 24.0 * (9.0 * d_by_dt.x + 19.0 * predicted.x - 5.0 * oldies.x + oldOldies.x);
     //   huOut = in_state_here_UV.y + dt / 24.0 * (9.0 * d_by_dt.y + 19.0 * predicted.y - 5.0 * oldies.y + oldOldies.y);
     //   hvOut = in_state_here_UV.z + dt / 24.0 * (9.0 * d_by_dt.z + 19.0 * predicted.z - 5.0 * oldies.z + oldOldies.z);
     //   cOut = in_state_here_UV.w + dt / 24.0 * (9.0 * d_by_dt.w + 19.0 * predicted.w - 5.0 * oldies.w + oldOldies.w);
     
        newState = in_state_here_UV + dt / 24.0 * (9.0 * d_by_dt + 19.0 * predicted - 5.0 * oldies + oldOldies);
        
    }

    // hack add for creating scalar "turbulence" at ship location
 //   if (abs(P_left) > 0.01) {
 //       newState.w = 1;
//    }
    if (id.x == 50)
    {
        newState.w = 1;
    }
    

    txNewState[id.xy] = newState;
    dU_by_dt[id.xy] = float4(d_by_dt);
    F_G_star[id.xy] = float4(F_star, G_star, 0.0, 1.0);
    current_stateUVstar[id.xy] = newState;

}