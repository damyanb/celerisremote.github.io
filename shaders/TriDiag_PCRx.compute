#pragma kernel TriDiag_PCRx

Texture2D<float4> coefMatx;
Texture2D<float4> current_state;
Texture2D<float4> current_stateUVstar;

int width;
int height;
int p;
int s;

RWTexture2D<float4> newcoefx; //  will store the updated state
RWTexture2D<float4> txNewState; //  will store the updated state

#pragma multi_compile THREADS_8x8 THREADS_16x16 THREADS_32x32

#ifdef THREADS_8x8
#define THREAD_X 8
#define THREAD_Y 8
#elif defined(THREADS_16x16)
#define THREAD_X 16
#define THREAD_Y 16
#elif defined(THREADS_32x32)
#define THREAD_X 32
#define THREAD_Y 32
#endif

[numthreads(THREAD_X, THREAD_Y, 1)]
void TriDiag_PCRx(uint3 id : SV_DispatchThreadID)
{
    int2 idx = int2(id.xy);
    
    float4 CurrentState = current_state.Load(int3(idx.x, idx.y, 0));
    
    // Initialize state
    newcoefx[id.xy] = float4(0.0, 0.0, 0.0, 0.0);
    txNewState[id.xy] = CurrentState;
    
    // return if in imaginary grid points
    if (idx.x >= width-2 || idx.y >= height-2) return;
    if (idx.x <= 1 || idx.y <= 1) return;

    int2 idx_left = int2((idx.x - s + width) % width, idx.y);
    int2 idx_right = int2((idx.x + s + width) % width, idx.y);

    float bIn,bInLeft,bInRight;
    float aIn,aInLeft,aInRight;
    float cIn,cInLeft,cInRight;
    float dIn,dInLeft,dInRight;

    if (p == 0) {
        bIn = coefMatx.Load(int3(idx, 0)).g;
        bInLeft = coefMatx.Load(int3(idx_left, 0)).g;
        bInRight = coefMatx.Load(int3(idx_right, 0)).g;

        aIn = coefMatx.Load(int3(idx, 0)).r / bIn;
        aInLeft = coefMatx.Load(int3(idx_left, 0)).r / bInLeft;
        aInRight = coefMatx.Load(int3(idx_right, 0)).r / bInRight;

        cIn = coefMatx.Load(int3(idx, 0)).b / bIn;
        cInLeft = coefMatx.Load(int3(idx_left, 0)).b / bInLeft;
        cInRight = coefMatx.Load(int3(idx_right, 0)).b / bInRight;

        dIn = current_stateUVstar.Load(int3(idx.x, idx.y, 0)).g / bIn;
        dInLeft = current_stateUVstar.Load(int3(idx_left.x, idx_left.y, 0)).g / bInLeft;
        dInRight = current_stateUVstar.Load(int3(idx_right.x, idx_right.y, 0)).g / bInRight;
        
    }
    else
    {
        aIn = coefMatx.Load(int3(idx, 0)).r;
        aInLeft = coefMatx.Load(int3(idx_left, 0)).r;
        aInRight = coefMatx.Load(int3(idx_right, 0)).r;

        cIn = coefMatx.Load(int3(idx, 0)).b;
        cInLeft = coefMatx.Load(int3(idx_left, 0)).b;
        cInRight = coefMatx.Load(int3(idx_right, 0)).b;

        dIn = coefMatx.Load(int3(idx, 0)).a;
        dInLeft = coefMatx.Load(int3(idx_left, 0)).a;
        dInRight = coefMatx.Load(int3(idx_right, 0)).a;
    }

    float r = 1.0 / (1.0 - aIn * cInLeft - cIn * aInRight);
    float aOut = -r * aIn * aInLeft;
    float cOut = -r * cIn * cInRight;
    float dOut = r * (dIn - aIn * dInLeft - cIn * dInRight);

    newcoefx[id.xy] = float4(aOut, 1.0, cOut, dOut);
    txNewState[id.xy] = float4(CurrentState.r, dOut, CurrentState.b, CurrentState.a);
}
